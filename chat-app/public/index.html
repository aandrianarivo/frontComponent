<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chat App</title>
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />
  <style>
    body, html { height: 100%; margin: 0; }
    .chat-container { display: flex; flex-direction: column; height: 100vh; }
    .messages-list {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      background-color: #f0f0f0;
    }
    .loader {
      text-align: center;
      margin: 0.5rem 0;
    }
    .message-bubble {
      max-width: 70%;
      padding: 0.75rem;
      border-radius: 1rem;
      line-height: 1.4;
    }
    .message-bubble.me {
      background-color: #dcf8c6;
      align-self: flex-end;
      border-bottom-right-radius: 0;
    }
    .message-bubble.other {
      background-color: #fff;
      align-self: flex-start;
      border-bottom-left-radius: 0;
    }
    .input-container {
      position: sticky;
      bottom: 0;
      background: #fff;
      padding: 0.5rem;
      border-top: 1px solid #ddd;
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div id="messages" class="messages-list">
      <div id="loader" class="loader d-none">
        <div class="spinner-border spinner-border-sm" role="status">
          <span class="visually-hidden">Chargement...</span>
        </div>
      </div>
    </div>
    <div class="input-container d-flex">
      <input id="user" class="form-control me-2" placeholder="Votre nom" required />
      <input id="text" class="form-control me-2" placeholder="Écrivez..." required />
      <button id="sendBtn" class="btn btn-primary">Envoyer</button>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const messagesEl = document.getElementById('messages');
    const loader = document.getElementById('loader');
    const inputUser = document.getElementById('user');
    const inputText = document.getElementById('text');
    const sendBtn = document.getElementById('sendBtn');
    let currentUser = '';

    let offset = 0;
    const limit = 3;
    let loading = false;

    // Crée une bulle DOM
    function createBubble(msg) {
      const div = document.createElement('div');
      const isMe = msg.user === currentUser;
      div.className = `message-bubble ${isMe ? 'me' : 'other'}`;
      div.innerHTML = `
        <strong>${msg.user}</strong>
        <p class="mb-1">${msg.text}</p>
        <small class="text-muted">${new Date(msg.timestamp).toLocaleTimeString()}</small>
      `;
      return div;
    }

    // Charge un batch et ajuste le scroll automatiquement
    async function loadBatch() {
      if (loading) return 0;
      loading = true;
      loader.classList.remove('d-none');
      const prevScrollHeight = messagesEl.scrollHeight;

      const res = await fetch(`/messages?offset=${offset}&limit=${limit}`);
      const { messages } = await res.json();

      loader.classList.add('d-none');
      if (messages.length) {
        if (offset === 0) {
          // Initial : append et scroll bottom
          messages.forEach(msg => messagesEl.append(createBubble(msg)));
          messagesEl.scrollTop = messagesEl.scrollHeight;
        } else {
          // Plus anciens : prepend avant le loader
          messages.reverse().forEach(msg => messagesEl.insertBefore(createBubble(msg), loader.nextSibling));
          // Ajuster le scroll pour conserver la position
          const newScrollHeight = messagesEl.scrollHeight;
          messagesEl.scrollTop = newScrollHeight - prevScrollHeight;
        }
        offset += messages.length;
      }

      loading = false;
      return messages.length;
    }

    // Initialisation : charger jusqu'à rendre scrollable ou plus de messages
    (async function init() {
      let fetched;
      do {
        fetched = await loadBatch();
      } while (messagesEl.scrollHeight <= messagesEl.clientHeight && fetched === limit);
    })();

    // Scroll en haut pour charger plus anciens
    messagesEl.addEventListener('scroll', () => {
      if (messagesEl.scrollTop === 0) {
        loadBatch();
      }
    });

    // Nouveaux messages temps réel
    socket.on('message', (msg) => {
      messagesEl.append(createBubble(msg));
      messagesEl.scrollTop = messagesEl.scrollHeight;
    });

    // Envoi de message
    sendBtn.addEventListener('click', () => {
      const user = inputUser.value.trim();
      const text = inputText.value.trim();
      if (!user || !text) return;
      if (!currentUser) {
        currentUser = user;
        inputUser.disabled = true;
      }
      socket.emit('newMessage', { user, text });
      inputText.value = '';
      inputText.focus();
    });
    inputText.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); sendBtn.click(); }
    });
  </script>
</body>
</html>